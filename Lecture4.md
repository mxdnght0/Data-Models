# Конспект лекции №4: Реляционная алгебра и основы SQL

## 1. Реляционная алгебра
Теоретическая основа реляционных баз данных. Операции работают над отношениями (таблицами) и возвращают новые отношения.

### Основные операции:

**Σ (σ) — Выборка (Selection)**
Выбирает кортежи, удовлетворяющие условию-предикату.
Пример в SQL: 
```
SELECT * FROM table WHERE условие
```

**Π (π) — Проекция (Projection)**
Возвращает вертикальное подмножество атрибутов.
Пример в SQL: 
```
SELECT column1, column2 FROM table
```

**∪ (Union) — Объединение**
Возвращает кортежи, присутствующие в любом из двух отношений (без дубликатов).

**∩ (Intersection) — Пересечение**
Кортежи, присутствующие в обоих отношениях.

**− (Difference) — Разность**
Кортежи, которые есть в первом отношении, но отсутствуют во втором.

**× (Cartesian Product) — Декартово произведение**
Каждый кортеж из одного отношения соединяется с каждым кортежем из другого.
В SQL: 
```
CROSS JOIN или перечисление таблиц в FROM
```

**⋈ (Join) — Соединение**
- Θ-соединение — по произвольному условию (> , < , =)
- Эквисоединение — по равенству атрибутов
- Естественное соединение — по совпадающим именам атрибутов

**÷ (Division) — Деление**
Операция, обратная соединению. Используется редко, в SQL реализуется через подзапросы или ```NOT EXISTS```.

### Замечания:
- Набор операций **избыточен**: некоторые операции можно выразить через другие
- В некоторых источниках указывают 5 базовых операций, в других — до 12

## 2. Реляционное исчисление
- Декларативный подход, ближе к языку запросов (например, SQL)
- Выражается через кванторы существования (∃)
- Пример: «Найти номера поставщиков, которые поставляют деталь P2»

## 3. Оптимизация запросов
- Запрос можно выполнить разными способами (планами), но с разной производительностью
- **Планировщик запросов** строит дерево операций и выбирает оптимальный порядок выполнения
- Критерии оптимизации: время выполнения, использование памяти
- При большом количестве джойнов используется эвристика или случайный порядок
- Современные СУБД используют **статистику** и **машинное обучение** для оптимизации

## 4. Порядок выполнения SQL-запросов
- **Синтаксический порядок:** ```SELECT → FROM → WHERE → GROUP BY → HAVING → ORDER BY → LIMIT```
- **Логический порядок выполнения:** ```FROM → JOIN → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT```
- Оптимизатор может менять порядок для ускорения

## 5. Типы данных: TIMESTAMP vs TIMESTAMPTZ

**TIMESTAMP WITHOUT TIME ZONE**
- Хранит время «как есть», без учёта часового пояса
- Пример: события, привязанные к локальному времени (дни рождения)

**TIMESTAMP WITH TIME ZONE**
- Хранит время в UTC и конвертирует при вводе/выводе
- Пример: международные системы, логи событий
- Рекомендация: использовать TIMESTAMPTZ, чтобы избежать путаницы

## 6. Операции модификации данных

### INSERT
- Лучше явно указывать атрибуты:
  ```INSERT INTO table (col1, col2) VALUES (v1, v2)```
- Защищает от ошибок при изменении схемы

**ON CONFLICT:**
- DO NOTHING — игнорировать конфликт
- DO UPDATE — обновить существующую запись (UPSERT)

### UPDATE
- Можно использовать данные из других таблиц через FROM:
```
UPDATE employees 
SET salary = salaries.amount 
FROM salaries 
WHERE employees.id = salaries.emp_id;
```

- RETURNING — вернуть обновленные данные
- Порядок присваивания работает корректно: ```UPDATE t SET a = b, b = a```

### DELETE
- Удаление с условием: ```DELETE FROM table WHERE условие```
- Поддерживает RETURNING

## 7. Триггеры и бизнес-логика
- **Триггеры** — функции, автоматически выполняемые при изменении данных
- **Не рекомендуется** размещать бизнес-логику в триггерах:
  - Нарушает принцип единой ответственности
  - Усложняет отладку и понимание кода
  - Логика оказывается размазанной между приложением и БД

## 8. Архитектура приложения и БД
- Рекомендуется разделять слои:
  - Data layer — хранение данных
  - Business logic layer — правила предметной области
  - Presentation layer — взаимодействие с пользователем
- База данных должна отвечать только за хранение и целостность данных

## 9. Автоинкремент и ручное указание ID
- Если вручную вставить запись с ID, которое уже есть в последовательности (sequence), может возникнуть конфликт
- Решение: использовать ```ON CONFLICT``` или избегать ручного назначения ID

## 10. Рекомендации по проектированию
- Всегда явно указывать атрибуты в INSERT
- Использовать TIMESTAMPTZ для временных меток
- Размещать бизнес-логику в приложении, а не в БД
- Использовать ```ON CONFLICT``` для обработки конфликтов
- Избегать ручного назначения ID при использовании автоинкремента
